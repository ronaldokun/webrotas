\"\"\"Unit tests for client-side avoid zones intersection logic.\"\"\"\n\nimport pytest\nfrom pathlib import Path\nfrom shapely.geometry import Polygon, LineString, MultiPolygon\nfrom shapely.strtree import STRtree\n\n# Import functions from app\nimport sys\nsys.path.insert(0, str(Path(__file__).parent.parent / \"src\"))\n\nfrom webrotas.app import (\n    check_route_intersections,\n    load_zones_version,\n    load_spatial_index,\n)\n\n\nclass TestCheckRouteIntersections:\n    \"\"\"Test route-polygon intersection calculations.\"\"\"\n\n    def test_route_fully_in_zone(self):\n        \"\"\"Route entirely within zone should have high penalty.\"\"\"\n        # Create a zone (square from -46.7 to -46.6, -23.55 to -23.5)\n        zone = Polygon([(-46.7, -23.55), (-46.6, -23.55), (-46.6, -23.5), (-46.7, -23.5)])\n        # Route fully inside the zone\n        route_coords = [(-46.65, -23.525), (-46.64, -23.525)]\n        tree = STRtree([zone])\n\n        result = check_route_intersections(route_coords, [zone], tree)\n\n        assert result[\"intersection_count\"] == 1\n        assert result[\"penalty_ratio\"] > 0.9  # Should be very high\n        assert result[\"route_length_km\"] > 0\n        assert result[\"total_length_km\"] > 0\n\n    def test_route_touching_zone_boundary(self):\n        \"\"\"Route crossing zone boundary should have medium penalty.\"\"\"\n        zone = Polygon([(-46.7, -23.55), (-46.6, -23.55), (-46.6, -23.5), (-46.7, -23.5)])\n        # Route touching edge (crosses from outside to inside)\n        route_coords = [(-46.61, -23.525), (-46.59, -23.525)]  # Touches at -46.6\n        tree = STRtree([zone])\n\n        result = check_route_intersections(route_coords, [zone], tree)\n\n        assert result[\"intersection_count\"] == 1\n        assert 0.1 < result[\"penalty_ratio\"] < 0.9  # Medium penalty\n        assert result[\"total_length_km\"] > 0\n\n    def test_route_avoiding_zone(self):\n        \"\"\"Route outside zone should have zero penalty.\"\"\"\n        zone = Polygon([(-46.7, -23.55), (-46.6, -23.55), (-46.6, -23.5), (-46.7, -23.5)])\n        # Route far from zone\n        route_coords = [(-46.5, -23.525), (-46.4, -23.525)]\n        tree = STRtree([zone])\n\n        result = check_route_intersections(route_coords, [zone], tree)\n\n        assert result[\"intersection_count\"] == 0\n        assert result[\"penalty_ratio\"] == 0.0\n        assert result[\"total_length_km\"] == 0.0\n        assert result[\"route_length_km\"] > 0\n\n    def test_route_multiple_zone_intersections(self):\n        \"\"\"Route crossing multiple zones should count all intersections.\"\"\"\n        zone1 = Polygon([(-46.7, -23.55), (-46.65, -23.55), (-46.65, -23.5), (-46.7, -23.5)])\n        zone2 = Polygon([(-46.63, -23.55), (-46.6, -23.55), (-46.6, -23.5), (-46.63, -23.5)])\n        # Route crossing both zones\n        route_coords = [(-46.71, -23.525), (-46.59, -23.525)]\n        tree = STRtree([zone1, zone2])\n\n        result = check_route_intersections(route_coords, [zone1, zone2], tree)\n\n        assert result[\"intersection_count\"] >= 1  # Crosses at least one zone\n        assert result[\"penalty_ratio\"] > 0\n        assert result[\"total_length_km\"] > 0\n\n    def test_empty_polygons_list(self):\n        \"\"\"Should return zero penalty when no polygons exist.\"\"\"\n        route_coords = [(-46.65, -23.525), (-46.64, -23.525)]\n\n        result = check_route_intersections(route_coords, [], None)\n\n        assert result[\"intersection_count\"] == 0\n        assert result[\"penalty_ratio\"] == 0.0\n        assert result[\"total_length_km\"] == 0.0\n\n    def test_route_with_single_point(self):\n        \"\"\"Should handle route with only one point gracefully.\"\"\"\n        zone = Polygon([(-46.7, -23.55), (-46.6, -23.55), (-46.6, -23.5), (-46.7, -23.5)])\n        route_coords = [(-46.65, -23.525)]  # Only one point\n        tree = STRtree([zone])\n\n        result = check_route_intersections(route_coords, [zone], tree)\n\n        # LineString with 1 point has zero length\n        assert result[\"route_length_km\"] == 0.0\n        assert result[\"intersection_count\"] == 0\n        assert result[\"penalty_ratio\"] == 0.0\n\n    def test_penalty_ratio_capped_at_one(self):\n        \"\"\"Penalty ratio should never exceed 1.0.\"\"\"\n        zone = Polygon([(-46.7, -23.55), (-46.6, -23.55), (-46.6, -23.5), (-46.7, -23.5)])\n        route_coords = [(-46.65, -23.525), (-46.64, -23.525)]\n        tree = STRtree([zone])\n\n        result = check_route_intersections(route_coords, [zone], tree)\n\n        assert result[\"penalty_ratio\"] <= 1.0\n\n    def test_results_are_rounded(self):\n        \"\"\"Length values should be rounded to 3 decimal places.\"\"\"\n        zone = Polygon([(-46.7, -23.55), (-46.6, -23.55), (-46.6, -23.5), (-46.7, -23.5)])\n        route_coords = [(-46.65, -23.525), (-46.64, -23.525)]\n        tree = STRtree([zone])\n\n        result = check_route_intersections(route_coords, [zone], tree)\n\n        # Check that values are properly rounded (max 3 decimals)\n        assert isinstance(result[\"total_length_km\"], float)\n        assert isinstance(result[\"route_length_km\"], float)\n        # Verify rounding works\n        assert len(str(result[\"total_length_km\"]).split(\".\")[-1]) <= 3\n\n\nclass TestLoadZonesVersion:\n    \"\"\"Test loading zone versions from disk.\"\"\"\n\n    def test_load_zones_with_missing_file(self, tmp_path):\n        \"\"\"Should raise FileNotFoundError when zones file doesn't exist.\"\"\"\n        # We can't easily test this without mocking, so we'll skip\n        # In real implementation, use tmp_path fixture\n        pass\n\n    def test_load_zones_with_invalid_format(self):\n        \"\"\"Should raise ValueError for invalid version format.\"\"\"\n        from webrotas.app import load_zones_version\n        \n        with pytest.raises(ValueError, match=\"Invalid version format\"):\n            load_zones_version(\"../../../etc/passwd\")  # Directory traversal attempt\n\n    def test_load_zones_with_dot_in_name(self):\n        \"\"\"Should reject version names with dots to prevent traversal.\"\"\"\n        from webrotas.app import load_zones_version\n        \n        with pytest.raises(ValueError, match=\"Invalid version format\"):\n            load_zones_version(\"avoidzones_20250110.150000\")  # Has dots\n\n\nclass TestLoadSpatialIndex:\n    \"\"\"Test spatial index building from GeoJSON.\"\"\"\n\n    def test_load_geojson_with_valid_polygon(self):\n        \"\"\"Should build spatial index from valid GeoJSON polygon.\"\"\"\n        geojson = {\n            \"type\": \"FeatureCollection\",\n            \"features\": [\n                {\n                    \"type\": \"Feature\",\n                    \"geometry\": {\n                        \"type\": \"Polygon\",\n                        \"coordinates\": [\n                            [[-46.7, -23.55], [-46.6, -23.55], [-46.6, -23.5], [-46.7, -23.5], [-46.7, -23.55]]\n                        ]\n                    },\n                }\n            ],\n        }\n\n        polys, tree = load_spatial_index(geojson)\n\n        assert len(polys) == 1\n        assert tree is not None\n        assert isinstance(tree, STRtree)\n\n    def test_load_geojson_with_multipolygon(self):\n        \"\"\"Should handle MultiPolygon features.\"\"\"\n        geojson = {\n            \"type\": \"FeatureCollection\",\n            \"features\": [\n                {\n                    \"type\": \"Feature\",\n                    \"geometry\": {\n                        \"type\": \"MultiPolygon\",\n                        \"coordinates\": [\n                            [[[-46.7, -23.55], [-46.65, -23.55], [-46.65, -23.5], [-46.7, -23.5], [-46.7, -23.55]]],\n                            [[[-46.63, -23.55], [-46.6, -23.55], [-46.6, -23.5], [-46.63, -23.5], [-46.63, -23.55]]],\n                        ],\n                    },\n                }\n            ],\n        }\n\n        polys, tree = load_spatial_index(geojson)\n\n        assert len(polys) == 2  # Should have 2 polygons from MultiPolygon\n        assert tree is not None\n\n    def test_load_geojson_with_invalid_geometry(self):\n        \"\"\"Should skip invalid geometries and continue.\"\"\"\n        geojson = {\n            \"type\": \"FeatureCollection\",\n            \"features\": [\n                {\n                    \"type\": \"Feature\",\n                    \"geometry\": {\n                        \"type\": \"Point\",  # Not a polygon\n                        \"coordinates\": [-46.7, -23.55]\n                    },\n                },\n                {\n                    \"type\": \"Feature\",\n                    \"geometry\": {\n                        \"type\": \"Polygon\",\n                        \"coordinates\": [\n                            [[-46.7, -23.55], [-46.6, -23.55], [-46.6, -23.5], [-46.7, -23.5], [-46.7, -23.55]]\n                        ]\n                    },\n                },\n            ],\n        }\n\n        polys, tree = load_spatial_index(geojson)\n\n        assert len(polys) == 1  # Only the polygon should be included\n        assert tree is not None\n\n    def test_load_geojson_with_no_polygons(self):\n        \"\"\"Should return empty lists when no valid polygons found.\"\"\"\n        geojson = {\n            \"type\": \"FeatureCollection\",\n            \"features\": [\n                {\n                    \"type\": \"Feature\",\n                    \"geometry\": {\n                        \"type\": \"Point\",\n                        \"coordinates\": [-46.7, -23.55]\n                    },\n                }\n            ],\n        }\n\n        polys, tree = load_spatial_index(geojson)\n\n        assert len(polys) == 0\n        assert tree is None\n\n    def test_load_single_feature_geojson(self):\n        \"\"\"Should handle single Feature (not FeatureCollection).\"\"\"\n        geojson = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [[-46.7, -23.55], [-46.6, -23.55], [-46.6, -23.5], [-46.7, -23.5], [-46.7, -23.55]]\n                ]\n            },\n        }\n\n        polys, tree = load_spatial_index(geojson)\n\n        assert len(polys) == 1\n        assert tree is not None\n\n\nclass TestIntegration:\n    \"\"\"Integration tests combining multiple components.\"\"\"\n\n    def test_complex_route_through_zones(self):\n        \"\"\"Test realistic scenario with multiple zones and route segments.\"\"\"\n        # Create two adjacent zones\n        zone1 = Polygon([(-46.7, -23.55), (-46.65, -23.55), (-46.65, -23.5), (-46.7, -23.5)])\n        zone2 = Polygon([(-46.65, -23.55), (-46.6, -23.55), (-46.6, -23.5), (-46.65, -23.5)])\n        \n        # Route that goes through both zones\n        route_coords = [\n            (-46.71, -23.525),  # Outside zone1\n            (-46.675, -23.525), # Inside zone1\n            (-46.625, -23.525), # Between zones\n            (-46.59, -23.525),  # Outside zone2\n        ]\n        \n        tree = STRtree([zone1, zone2])\n        result = check_route_intersections(route_coords, [zone1, zone2], tree)\n        \n        assert result[\"intersection_count\"] >= 1\n        assert result[\"penalty_ratio\"] > 0\n\n    def test_long_distance_route(self):\n        \"\"\"Test with longer route (São Paulo routing scenario).\"\"\"\n        zone = Polygon([(-46.7, -23.55), (-46.6, -23.55), (-46.6, -23.5), (-46.7, -23.5)])\n        \n        # Long route across São Paulo area\n        route_coords = [\n            (-46.5, -23.6),\n            (-46.55, -23.57),\n            (-46.65, -23.525),  # Crosses zone\n            (-46.75, -23.48),\n        ]\n        \n        tree = STRtree([zone])\n        result = check_route_intersections(route_coords, [zone], tree)\n        \n        assert result[\"route_length_km\"] > 10  # Long route\n        assert result[\"intersection_count\"] >= 0\n"